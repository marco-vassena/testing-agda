\documentclass[10pt,a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{agda}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fancyvrb}

\DeclareUnicodeCharacter{8759}{::}
 
\DefineVerbatimEnvironment
   {code}{Verbatim}
   {} % Add fancy options here if you like.

\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\author{Marco Vassena - 4110161}
\title{Testing Agda}
\begin{document}
\maketitle

\section{Introduction}
Inspired by libraries like Quickcheck, Smallcheck and FEAT, the goal of this experimentation project is to design and implement a library for testing decidable properties for Agda, a total, dependently typed functional programming language.

\subsection{Motivation}
Under the Curry-Howard correspondence, it is possible to use Agda to formally prove arbitrary properties. The reader might then wonder what would be the benefit of a testing library in such a setting. Proving properties is in general hard and time-consuming, therefore it could be useful, before undertaking this demanding task, to verify that the property at hand holds with concrete input values. This sanity-check can be achieved by means of this library and could quickly spot erroneous definitions and invalid or incomplete theorems.

\section{Library}
The library is organized as follows:
\begin{itemize}
	\item \texttt{Test.Base}. Basic data-type definitions.
	\item \texttt{Test.Result}. Provides feedback to the user.
	\item \texttt{Test.Converter}. Automatic conversion from lemmas' type signature to predicate.
	\item \texttt{Test.Input}. Provides input values to the testing framework.
	\item \texttt{Test.Tester}. Testing framework.
	\item \texttt{Test.Runner}. Different ways to run tests.
	\item \texttt{Example} Contains several simple examples about how to use the library.
	
\subsection{Predicate}
The \texttt{Predicate} data-type is a universe that represents first order logic predicates.

\begin{code}
data Predicate : (BListTree Set) → Set₁ where
  Forall : (p : A → Predicate xs) → Predicate (A ∷ xs)
  Exists : (p : A → Predicate xs) → Predicate (A ∷ xs)
  ExistsUnique : (p : A → Predicate xs) → Predicate (A ∷ xs)
  Not : Predicate xs → Predicate xs
  _∨_ : Predicate xs → Predicate ys → Predicate (xs , ys)
  Property : (P : Set) → Predicate []
\end{code}

In other testing libraries predicates are limited to boolean formulas, in this setting instead, consistently with the Curry–Howard equivalence, types are the basic building block of a predicate, which explains the basic constructor \texttt{Property} which wraps a \texttt{Set} element.

The constructors \texttt{Forall}, \texttt{Exists} and \texttt{ExistsUnique} add quantification to the \texttt{Predicate} data type.
Exploiting the underlying high-order language, the quantification is represented as a continuation (lambda expression), which literally introduces a new variable in scope, available in the remaining part of the predicate and ultimately in  the type \texttt{P} inside a \texttt{Property}.

The data type is indexed over a \texttt{BListTree} which keeps track of the types of the quantified variables and whose avail will be explained in the following.
The definition of \texttt{BListTree} is straightforward:
\begin{code}
data BListTree {a} (A : Set a) : Set a where 
  [] : BListTree A
  _∷_ : A → BListTree A → BListTree A
  _,_ : BListTree A → BListTree A → BListTree A
\end{code}
The constructor \texttt{\_::\_} is used when quantification add a variable in scope, whereas the constructor \texttt{\_,\_} couples together the \texttt{BListTree} when two predicates are composed by the disjunction constructor \texttt{\_$\vee$\_}.

Other derived combinators have been defined on top of the \texttt{Predicate} 
data type, such as implication, conjunction and double implication.

\paragraph{Example}
The following is an example of the predicate $\forall n \in \mathbb{N} . \exists m \in \mathbb{N} . Even (n + m)$. The \texttt{BListTree} constructor \texttt{\_::\_} (cons) fixes the type of the variables quantified.  

\begin{lstlisting}
example1 : Predicate ($\mathbb{N}$ :: $\mathbb{N}$ :: [])
example1 = Forall ($\lambda$ n $\rightarrow$ (Exists $\lambda$ m $\rightarrow$
		(Property (Even (n + m))))
\end{lstlisting}
Special syntax declarations has been used to hide the presence of the lambda abstractions and keep the predicate readable and avoid clutter.
\begin{lstlisting}
example1-pretty : Predicate ($\mathbb{N}$ :: $\mathbb{N}$ :: [])
example1-pretty = Forall n $\sim$ Exists m $\sim$ 
			Property (Even (n + m))
\end{lstlisting}
Another example showing additional constructs available in \texttt{Predicate}.
\begin{lstlisting}
example2 : Predicate ($\mathbb{N}$ :: ([] , []))
example2 = Forall n $\sim$ Property (Even n) $\vee$ 
                       Not (Property (Even n))
\end{lstlisting}
\end{itemize}

\subsection{Testing framework}
The data type \texttt{Testable} represents a minimal testable unit.

\begin{code}
data Testable : (BListTree Set) → Set₁ where
  Test_on_by_ : (p : Predicate xs )→ Input List xs →  ⟦ p ⟧ → Testable xs
\end{code}

It contains a predicate $p$ of type \texttt{Predicate xs}, a collection of input values of type \texttt{Input List xs} and the testing function $\llbracket$ \texttt{p} $ \rrbracket$. The shared index \texttt{xs} of type \texttt{BListTree} guarantees that the collection of input values match the shape and the types contained in the predicate.

The type level function $\llbracket\_\rrbracket$, given a predicate, returns the type of a decision procedure used to test that property.
Such function takes as many arguments as variables quantified and returns a \texttt{Dec} relation over the final property.
Its definition is straightforward:
\begin{code}
⟦_⟧ : Predicate xs → Set
⟦ Forall {A = A} f ⟧ = (a : A) → ⟦ f a ⟧
⟦ Exists {A = A} f ⟧ = (a : A) → ⟦ f a ⟧
⟦ ExistsUnique {A = A} f ⟧ = (a : A) → ⟦ f a ⟧
⟦ Not p ⟧ = ⟦ p ⟧
⟦ p1 ∨ p2 ⟧ = ⟦ p1 ⟧ × ⟦ p2 ⟧
⟦ Property P ⟧ = Dec P
\end{code}
For each quantified variable, denoted by existential and quantification 
constructors, we require an argument of that type. The rest of the signature is 
filled applying the  $\llbracket\_\rrbracket$ function to the remaining 
part of the predicate that becomes accessible applying the continuation 
\texttt{f} to the argument \texttt{a}.
In the disjunction  case the decision procedure of each predicate are paired together. The base case (\texttt{Property}) requires decidability over the final type \texttt{P}.

\paragraph{Example}
This is the type signature of the decision procedure required to test \texttt{example1}:
\begin{lstlisting}
$\llbracket$ example1 $\rrbracket$ $\equiv$ (n : $\mathbb{N}$) $\rightarrow$ (m : $\mathbb{N}$) $\rightarrow$ Dec (Even (n + m))
\end{lstlisting}
Suppose that a decidability procedure for the \texttt{Even} relation is available as \texttt{even? : (n : $\mathbb{N}$) $\rightarrow$ Even n}, then a suitable decision procedure for \texttt{example1} is:
\begin{lstlisting}
example1-dec : $\llbracket$ example1 $\rrbracket$
example1-dec n m = even? (n + m)
\end{lstlisting}
Note that the simple, yet precise, definition of $\llbracket\_\rrbracket$ 
and the power of dependent types can prevent subtle bugs in the specification.
For instance providing the following decision procedure for \texttt{example1} will raise a type error, because \texttt{n} is different from \texttt{n + m}:
\begin{lstlisting}
wrong : $\llbracket$ example1 $\rrbracket$ 
wrong n m = even? n
\end{lstlisting}


The data type \texttt{Input} stores the input values used to test the predicate.
\begin{code}
data Input (F : Set → Set) : (BListTree Set) → Set₁ where
  [] : Input F []
  _∷_ : F A → Input F xs → Input F (A ∷ xs)
  _,_ : Input F xs → Input F ys → Input F (xs , ys)
\end{code}
It is indexed over a \texttt{BListTree} which determine its shape and the type of the values contained and polymorphic over \texttt{F}, which is the container of the input values.
The testing framework requires \texttt{Input List}, but following the example of \texttt{Test.Input.Stream} it's possible to use arbitrary containers as long as they can be internally converted to the \texttt{Input List} data type.
Its constructors are overloaded version of the \texttt{BListTree} constructors, so that it has also visually the same shape of the property's \texttt{BListTree}.
\paragraph{Example} An example of \texttt{Input List} for \texttt{example1}.
\begin{lstlisting}
example1-input : Input List ($\mathbb{N}$ :: $\mathbb{N}$ :: [])
example1-input = (0 :: 1 :: 2 :: 3 :: []) :: 
		 (0 :: 1 :: 2 :: 3 :: []) :: []
\end{lstlisting}


The testing framework comprises a family of mutually recursive testing functions, each specialized to deal with a specific constructor of the \texttt{Predicate} data type, all returning a tagged \texttt{Result}, which models all the possible outcomes of testing a first order predicate. 
The tag (constructor \texttt{inj₁} or \texttt{inj₂}) represents whether for the current input value the property turned out to be valid or not.

The entry point of the testing framework is the function \texttt{test'}:
\begin{code}
test' : (u : Predicate xs) → ⟦ u ⟧ → Input List xs → Result xs ⊎ Result xs
test' (Forall p) check (x ∷ input) = test∀ (Forall p) check x input
test' (Exists p) check (x ∷ input) = test∃ (Exists p) check x input
test' (ExistsUnique p) check (x ∷ input) = test∃! (ExistsUnique p) check x input
test' (Not p) check xs with test' p check xs
test' (Not p) check xs | inj₁ x = inj₂ x
test' (Not p) check xs | inj₂ y = inj₁ y 
...
test' (Property P) (yes p) [] = inj₂ (Hold P)
test' (Property P) (no ¬p) [] = inj₁ (DoesNotHold P)
\end{code}
For the non quantified constructors (negation and disjunction) the semantics of the combinators is directly expressed by the function itself.
Otherwise if the predicate is quantified it will dispatch the predicate to the specific testing function that deals with the given quantifier.
As an example consider \texttt{test∀}, which deals with universally quantified predicates.
The type levels function \texttt{is∀} maps non universally quantified predicates in the empty type \texttt{$\bot$}, which discards the spurious cases with the  absurd pattern \texttt{()}.
The \texttt{List A} argument represents the search space over which universal quantification has to be tested.
If this list is empty in the first place then the universal quantification is technically (although trivially) valid. Otherwise the predicate is tested with the first element present in the list. This is done by calling recursively the dispatch function \texttt{test'}, feeding the argument both to the continuation of the predicate and of the decision procedure. This mechanism is common to all the testing functions that deal with quantifiers (\texttt{test∃!}, \texttt{test∃}, \texttt{test∀}). 	
\begin{code}
test∀ : (u : Predicate (A ∷ xs)) {p : is∀ u} → ⟦ u ⟧ → List A → 
         Input List xs → Result (A ∷ xs) ⊎ Result (A ∷ xs)
test∀ (Forall p) check [] input = inj₂ Trivial
test∀ (Forall p) check (x ∷ xs) input with test' (p x) (check x) input
test∀ {A = A} (Forall p) check (x ∷ xs) input | inj₁ r = inj₁ (NotFor x r)
test∀ {A = A} (Forall p) check (x ∷ []) input | inj₂ y = inj₂ (Forall A y)
test∀ {A = A} (Forall p) check (x ∷ x₁ ∷ xs₁) input | inj₂ y = 
	test∀ (Forall p) check (x₁ ∷ xs₁) input
test∀ (Exists p) {()} check xs₁ input
test∀ (ExistsUnique p) {()} check xs₁ input
test∀ (Not u) {()} check xs₁ input
\end{code}
The rest of the function simply expresses the semantics of universal quantification: if the current input value represents a counter example, a failure is reported
(\texttt{inj₁ (NotFor x r)}), otherwise more values are tested until the search space is exhausted.

Eventually, after filling the decision procedure \texttt{⟦ u ⟧} one argument at the time, the final \texttt{Property} will be analyzed in \texttt{test'}.
At this point, when \texttt{⟦ u ⟧} has been completely saturated, the result is a decision statement about \texttt{P}, which is mapped directly to correspondent tag.
What is interesting here is that \texttt{P} represents the original property in which also the quantified variables have been fixed to some values, during the testing process. 
This information is returned as it may represent useful feedback for the user. As an example consider testing \texttt{Forall n $\sim$ Even n} over the natural numbers. The test will fail, finding a counter example for 1 and reporting \texttt{DoesNotHold (Even 1)}, providing a readable version of the outcome.

\subsection{Runner}
The module \texttt{Test.Runner} defines different runners.
A runner is a type level function that uses directly the underlying testing framework and after running a test returns a specific wrapper data-type that provides readable feedback to the user.

The simplest runner is \texttt{run}, which simply runs the test and reports whether it failed or not returning either the type \texttt{Fail} or \texttt{Succeed}. These types have only one inhabitant and then the result of running a test can be filled automatically with Agda's \texttt{auto} feature.
The runner \texttt{runVerbose} additionally returns also the actual \texttt{Result} produced by the testing framework. This is either a witness of the correctness of the property or a counterexample.
Special care have been put in making the feedback as useful and readable as possible for the user. This is discussed in more detail in section 	\ref{sec:Result}.
In both cases the \texttt{Result} is an index of the returned type and argument of the only constructor of this data-type. In previous version of this library 
Agda's \texttt{auto} feature could infer the only inhabitant of the type.
Unfortunately this turned out not to work anymore when the \texttt{BListTree} was added as an index to \texttt{Result}. This is currently tracked as a \href{http://code.google.com/p/agda/issues/detail?id=1223}{bug}. Hopefully later version of agda will fix it, solving this issue. At the moment it's still possible to manually fill such holes copying the witness or counterexample from the environment.	
The runners \texttt{pass} and \texttt{fail} require the test to respectively pass and fail. The runner \texttt{skip} does not run the test at all.
The runners \texttt{pass\_With\_Using} and \texttt{fail\_With\_Using} are variants of the runners \texttt{pass} and \texttt{fail} in which the user specifies not only whether the test should pass or not, but also with which outcome.
These runners require decidable equality over the types involved in the property, which are contained in a \texttt{Comparator} object.
The \texttt{Comparator} shares the same \texttt{BListTree} index  of the property  being tested, which guarantees that is contains the decidable equality functions for the correct types and that it has the same shape.
The same overloaded constructors for a \texttt{BListTree} have been used to help the user's intuition, in the same way it has been done for the \texttt{Input} data type.
The only flaw of this runner it's that it is not able to compare the expected and actual property. The problem is that these are types (\texttt{Set}) for which equality cannot be decided by the user, but only by the type checker.
Therefore at the moment they are optimistically considered equal, even tough the actual set could be different from the expected one.

\subsection{Result}
\label{sec:Result}
The module \texttt{Test.Result} defines the data-type \texttt{Result} which represents a normalized outcome of testing a predicate.
There is also an internal version of this data-type in the module \texttt{Test.Base}.
The latter is used in the testing framework, whereas the former is exposed to the final user. The exposed version has been added to provide sensible feedback to the user. The internal result cannot be used directly because it contains partial results of the testing process, which may not be sensible to show. For instance consider the predicate $\forall n \in \mathbb{N} : Even (n + 0)$. After testing the predicate for a subset of the natural numbers $n$ will be bound to the last number tested. This kind of information needs to be hidden and this is done converting the internal result in the exposed result by the functions \texttt{normalize} and \texttt{hide}.

\paragraph{Example} The \texttt{Result} data type returned for the previously mentioned property would be.

\begin{lstlisting}
example3-result : Result ($\mathbb{N}$ :: [])
example3-result = ForAll < $\mathbb{N}$ > $\checkmark$
\end{lstlisting}
In other situations these partial values are useful and retained:
\begin{lstlisting}
example4-result : Result ($\mathbb{N}$ :: [])
example4-result = $\exists$ $\langle$ 0 $\rangle$ Even 0
\end{lstlisting}

\section{Conversion}
The library provides in the module \texttt{Test.Conversion} the function \texttt{convert} which automatically converts the signature of a lemma (yet to be proven) to the correspondent predicate. Dependent types are converted to universal quantification and standard library constructs such as $\neg$, $\exists$, $\biguplus$, $\times$ are recognized and mapped to their \texttt{Predicate} counterpart.
In order to achieve its purpose this module relies on the \texttt{Reflection} module from the standard library.

\section{Generator}
Generators definition.

\subsection{•}
Generators for simple types: SimpleGenerator.

\subsection{Dependent types generator}
Nature of dependent types : Provide additional information, Represent constructively properties about values.
Generators for dependent types: Angelic and Demoniac generators.
Implementing one generator or the other is easier based on the nature of the dependent type at hand.
Example.

\subsection{Productivity}
Limitations of productivity checker.
Danielsson workaround.
Additional contribution:
	concatMap / concatMap'
Productivity data type
	Sound, but incomplete version
	Sound and complete version
		
\section{Complete Test Case ?}
Lambda-calculus, small step semantics, deterministic proof.

\section{Further Work}
This project leaves room for further extensionsq to the library.
\begin{itemize}
	\item The library currently supports only decidable properties. It would be useful handle also partially-decidable properties and investigate alternative approaches for undecidable properties.
The framework currently supports only decidable properties, because in this setting it is always clear the distinction between a success and a failure.
However further extensions might tackle the problem of testing undecidable or only partially decidable properties.

	
	
	\item The user needs to write custom generator for each data-type under testing. The library could give support in writing such generators, or even generate them using a generic approach. Particularly relevant in this setting is the generation of dependent values.
	\item A crucial aspect of this library is giving precise, readable and informative feedback to the user. Adding more constructors to the \texttt{Predicate}, rather then just mapping them to basic constructors (as it happens for conjunction, implication and bi-implication, could certainly improve the quality of the results, because they could be tailored for each constructor. The normalization of the internal \texttt{Result} data type could also be improved further with this goal in mind.
\item Note that this implies that in general is not possible to analyze a predicate for finding out information about its structure. This is one of the major drawback of this data structure.

\end{itemize}

\end{document}