\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\author{Marco Vassena - 4110161}
\title{Testing Agda}
\begin{document}
\maketitle

\section*{Introduction}
Inspired by libraries like Quickcheck, Smallcheck and FEAT, the goal of this experimentation project is to design and implement a library for testing decidable properties for Agda, a total, dependently typed functional programming language.

\subsection*{Motivation}
Under the Curry-Howard correspondence, it is possible to use Agda to formally prove arbitrary properties. The reader might then wonder what would be the benefit of a testing library in such a setting. Proving properties is in general hard and time-consuming, therefore it could be useful, before undertaking this demanding task, to verify that the property at hand actually holds. This sanity-check can be achieved by means of this library and could quickly spot erroneous definitions and invalid or incomplete theorems.

\section*{Library}

The library is organized as follows:
\begin{itemize}
	\item \texttt{Test.Base}. Basic data-type definitions.
	\item \texttt{Test.Result}. Provides feedback to the user.
	\item \texttt{Test.Converter}. Automatic conversion from type signatures to predicates.
	\item \texttt{Test.Input}. Provides input values to the framework.
	\item \texttt{Test.Tester}. Tests properties.
	\item \texttt{Test.Runner}. Different ways to run tests.
	\item \texttt{Example} Contains several simple examples about how to use the library.
	
\subsection*{Predicate}
The \texttt{Predicate} data-type represents a predicate in first order logic.
It includes universal, existential and unique existential quantification, conjunction, disjunction, negation, implication and bi-implication.
In other testing libraries predicates are limited to boolean formulas, in this setting instead, consistently with the Curryâ€“Howard equivalence, types are the basic building block of a predicate, which are wrapped by the \texttt{Property} constructor.
The data type is indexed over a \texttt{BListTree} which keeps track of the types of the quantified variables and whose avail will be explained in the following.
The definition of the quantification constructs is the most interesting.
Exploiting the underlying high-order language, the quantification is represented as a continuation (lambda expression), which literally introduces a new variable in scope, available in the remaining part of the predicate.
Special syntax declarations hide the presence of the lambda abstractions and keep the predicate readable.

% Example of predicate and BListTree
% Example pretty syntax

\end{itemize}

\subsection*{Testing framework}
The data type \texttt{Testable} contains a predicate $p$ of type \texttt{Predicate xs}, a set of input values of type \texttt{Input List xs} and the testing function $\llbracket p \rrbracket$ and represent a minimal testable unit. The shared index \texttt{xs} guarantees that the collection of input values match the shape and the types contained in the predicate.
The type level function $\llbracket \cdot \rrbracket$, given a predicate, returns the type of a decision procedure used to test the property.
Such function takes as many arguments as variables quantified and returns a \texttt{Dec} relation over the final property. Due to this only decidable predicates can be tested, however further extensions might tackle the problem of testing undecidable or partially decidable properties.

% Example of [[ ]]

The testing framework comprises a family of mutually recursive testing function, each specialized to deal with a specific constructor of the \texttt{Predicate} data type. These functions return a tagged \texttt{Result}.
The tag (constructor $inj_1$ or $inj_2$) represents whether for the current input value the property turned out to be valid or not.
Based on that for each kind of construct of the predicate a different behaviour is defined, accordingly to its semantics.
For instance universal quantification will test all the given input values until either the search space is exhausted or a counter example is found. Conversely existential quantification will stop as soon as an input value validates the predicate.
These functions rely on the continuation passing style.
The decision procedure $\llbracket \cdot \rrbracket$ is saturated passing an input value at each node of the predicate, until lastly at the leaf \texttt{Predicate} a decidable instance about the property (for some specific input values) is obtained.
Since also the \texttt{Predicate} data-type relies on continuation input values are required to traverse a predicate and get to the next constructor.
Note that this implies that in general is not possible to analyze a predicate for finding out information about its structure. This is one of the major drawback of this data structure.

% Input
% Runner
% Conversion
% Result
\section*{Example}

\section*{Further Work}

\end{document}